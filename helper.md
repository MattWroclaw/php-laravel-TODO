1. Włączamy server za pomocą `php artisan serve` (it takes some good time), działa na localhost:8000 (*nie zapomnij włączyć Dockera z bazą danych*)
2. Lista wszystkich routingów `php artistan route:list`
3. layouts -> tam dajemy wspólne el. html, które będa dziedziczone w blades
4. dodanie bazy danych: zmiana portu w dockerfile na 3305, w `.env` na 3305, zmieniamy w `.env` to `DB_DATABASE=laravel-10-task-list` zatrzymujemy server i robimy `php artisan migrate` Później piszemy `yes` gdy zapyta się czy stworzyć nową bazę. 
5. Jak mieliśmy otwartego `Adminer` to trzeba zamknąć i otworzyć przeglądarkę na `http://localhost:8080` i powinna być baza danych `laravel-10...` Ona ma też kilka defaultowych kolumn
6. Tworzenie modelu: `php artisan make:model Task -m` Task= nazwa modelu, `-m` -> stworzy całą migrację dla niego (ale jeszcze nie ma żadnych zmian w DB)
7. W laravel jak model jest Task, to tabela w DB będzie się nazywała 'tasks' (plural). Dlatego też Model "Task" będzie wiedział ze ma się odwoływać do tabeli 'tasks"
8. W ./database/migrations są migrations. One za pomocą php tworzą tabele w DB, są jakby vcs bazy danych. Można tworzyć, zmieniać ususwać kolumny za pom. php
9. W *Migration*  funkcja `up` -> coś wykonuję na tabelach. Funkcja `down` cofam
10. Migracje można też wykonać za pomocą komendy `php artisan make:migration` (ale nie mówił nic więcej o tym)
11. Po wykonaniu Modelu za pomocą komendy z p.6. , wchodizmy do ./Database/Migrations i szukamy tej migracji. Wewnątrz niej w funkcji `up` tworzymy potrzebne nowe kolumny. Żeby zastosować *Migration* wykonujemy komendę `php artisan migrate`
12. Aby zrobic roll-back to sosujemu `php artisan migrate:rollback`
13. Tworzenie fake-data w bazie danych. Wykorzysutjemy ./Database/factories i ./Database/seeders. W *Seeder* ładujemy dane do bazy danych; uruchamiamy factory. W *UserFactory* ustalamy jakie mają być wartości
14. Komenda do uruchomienia *seed* `php artisan db:seed` . *Ta komenda zawsze doda nowe dane do DB*. 
15. *Tworzenie factory dla nowego modelu* , w naszym przypadku Task komenda: `php artisan make:factory TaskFactory --model=Task` Tam wypełniamy jakimi fakowymi danymi ma być wypełniony obiekt. Następnie w `seeders` podajemy  ścieżke do Factory dla danego obiektu (u nas Task); podajemy ile ma być linii, i metodę `create`
15. 1. Komenda na dodanie do bazy danych `php artisan db:seed` ale to doda nowe rekordy w DB
15. 2. _Nigdy na PROD!_  W przypadku, gdy już mamy jakies dane w DB (i nie chcemy żeby nowi Userzy się dodali przy dodawaniu np. Tasków) wykonujemy komndę: `php artisan migrate:refresh --seed` To robi roll-backa na wszystko i tworzy nową bazę danych.
16. W web.php w kontorlerze odwołujemy się do Modelu (Task w naszym przykładzie) I tam korzystamy z metody statycznej `find()` . To jest w docu https://laravel.com/docs/11.x/queries#main-content 
Możemy zatrzymać server, i wpisać `php artisan tinker` i możemy pisać queries do applikacji. Np `\App\Models\Task::all();`  Możemy sobie sprawdzić czy mamy dobre query! ` \App\Models\Task::select('id' , 'title')->where('completed',true)->get() `
17. **Uwaga!! Kolejność kontrolerów ma znaczenie!!** Jak jest najpierw `/task/{id}` a potem zrobimy `/task/create` to się wysypie, 404!
18. `@csrf` że nie możne "zły skrypt" wysłać requesta na inny endpoint w imieniu tego zalogowanego usera. W kolejnym zdaniu mówi, że ktoś inny nie może za zalogowanego usra wysłać requestu na `tą` stronę. Ciekawostką jest to, że laravel dołącza do każdego forma inny token i będzie go veryfikował przy otrzymaniu danych z formularza. Jeśli zapomni się o `@csrf` dodać do formularza to jest błąd 419 (?) Można to excludnąć w `App\Middleware\VerifyCsrfToken.php`
19. W formularzu w <input> mamy `name=..` oraz `id=..`  Name -> odnosi się do danych dostarczony przez formularz; id -> łączy labelkę z Input'em, to znaczy, że jak ktoś kliknie na labelkę, to dany input będzie aktywny
20. Validation errors są przechowywane w User Session. W `Session` jest to sposób na zapisanie odwiedzin Usera na stronie, w serwisie. Tworzy się jak się loguje, niszczy się jak się wyloguje. Można przechowywać np. numer karty kredytowej. Nas interesuje `errors` które można wyświetlić oraz "flash messages" -> onSuccess. One są tylko w danej sessji.
20. 1. Kiedy wchodzisz na servis na Laravelu , to laravel tworzy session (przypisuje jakiś uniqueID). To jest przechowywane w cookie. Jak przechodzisz z widoku na widok, to zawsze to session też idzie. Na tej podstawie Laravel widzi że to ten sam user. Sessions są przechowywane w `./storage/framework/sessions`. Confifgurację przeprowadza się w `session.php` . Session dobrze jak jest przechowywana w `redis` a nie w file. Bo jak jest apka na kilku serverach to nie ma jak tego współdzielić.
20. 2. funkcja `session()` jest dostępna w blade i w `web.php`
21. HTML przyjmuje tylko 'POST' i 'GET' , nie można bezpośrednio dać 'PUT'. W Laravel stosuje się tzw. `method spoofing`. Metoda POST będzie miała dodatkowe pole `_method=PUT`. Laravel jak odkryje ze jest _method=PUT to zrobi redirect do kontorlera PUT. Implementacja: w formularzu dodaje się pod @csrf adnotację `@method('PUT')`
22. Jak tworzymy Task, wpiszemy cześć dobrze a część źle, to validation usunie wszystko. Alby zachować to co jest OK, korzystamy w `create.blade.php` z metody `old('nazwa pola')`. *Uwaga* : to nie zadziała z metodą GET. *Uwaga2* : nie korzystamy z metody `old()` przy credkach
23. Jeśli w metodach w `web.php` nie korzystamy z `id` tylko bezpośrednio z obiektu `Route::get('/tasks/{task}', function (Task $task)` to Laravel zakłada że {task} to jest `id` . Dlatego też URL wygląda tak: http://localhost:8000/tasks/3 . Domyślnie brany jest id obiektu, ale można to zmienić w obiekcie modelu `class Task extends Model { .. pyblic function getRouteKeyName(){return "slug";}}`
24. Jeśli mamy takie same validation rules, możemy użyć `form request`  . Automatyzacja przez komendę: `php artisan make:request TaskRequest` . Ta komenda tworzy nam:  INFO  Request [C:\Projects\Playground\PHP-kurs-udemy\task-list\app\Http\Requests\TaskRequest.php] created successfully. 
24. `Mass assignment`:  Wewnątrz "controlerów" zamiast Tworzyć new Task, później robić settery i robi save, to można załatwić za pomocą Task::`create()` albo `update()`. Tylko że trzeba zmienić w Modelu Task
25. W laravel jest coś takiego jak `soft delete` Dodatkowa kolumna w DB
26. Korzystanie z `subview` za pomocą dyrektywy `@include` . Przykład: `create.view` oraz `update.view` są bardzo podobne, więc można wykorzystać wspólny kod. Wtedy w subview sprawdzamy czy mamy obiekt $task i jeśli tak to robimy update (i zmieniamy metodę, button etc.)